{"title":"Java面试","date":"2019-12-09T12:45:48.304Z","link":"post/Java面试","updated":"2019-12-09T12:45:40.217Z","content":"<h3 id=\"Java面试考点\">Java面试考点<a href=\"post/Java面试#Java面试考点\"></a></h3><p><strong>写在前面的话：</strong></p>\n<p>​    <strong>1. 面试需要长期积累</strong></p>\n<p>​    <strong>2. 合理利用搜索引擎，培养主动解决问题的能力</strong></p>\n<h4 id=\"1-Java考点\">1. Java考点<a href=\"post/Java面试#1-Java考点\"></a></h4><p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1572610742574.png\" alt=\"1572610742574\" class=\"article-img\"></p>\n<h5 id=\"1-1-问题一：谈谈对Java语言的理解\">1.1 问题一：谈谈对Java语言的理解<a href=\"post/Java面试#1-1-问题一：谈谈对Java语言的理解\"></a></h5><p>从以下几个方面：</p>\n<ul>\n<li>平台无关性(Compile Once，Run Anywhere即一次编译，到处运行)</li>\n<li>面向对象：封装、继承、多态</li>\n<li>GC(垃圾回收机制)：无需像C++一样手动释放内存</li>\n<li>语言特性：泛型、反射、Lambda表达式</li>\n<li>类库：Java本身自带的集合、并发库、网络库、IO和NIO等</li>\n<li>异常处理</li>\n</ul>\n<h5 id=\"1-2-问题二：Compile-Once，Run-Anywhere如何实现\">1.2 问题二：Compile Once，Run Anywhere如何实现<a href=\"post/Java面试#1-2-问题二：Compile-Once，Run-Anywhere如何实现\"></a></h5><p><strong>即考察平台无关性(Compile Once，Run Anywhere的前提是JDK或JRE版本相同)</strong></p>\n<p>Java源码首先被编译成字节码，再由不同平台的JVM进行解析，<strong>Java语言在不同的平台上运行时不需要进行重新编译</strong>，Java虚拟机在执行字节码的时候，再把字节码转换成具体平台上的机器指令。 </p>\n<p>首先，源代码经由javac编译生成字节码并保存在.class文件中。字节码和.class文件就是跨平台的基础。再由不同平台的JVM加载执行对应的.class文件。 </p>\n<p><strong>javac</strong>指令将源码编译生成字节码，并存入对应的.class文件。.class文件保存源码翻译的二进制字节码文件，同时会添加一个共有的静态常量属性class，该属性记录了类的相关信息及类型信息，是class的一个实例。</p>\n<p><strong>java</strong>指令使JVM解析对应的.class文件，将字节码加载进内存，并转换成操作系统能够识别的机器码去执行</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1572613736866.png\" alt=\"1572613736866\" class=\"article-img\"></p>\n<p><strong>如何查看字节码文件</strong></p>\n<p><strong>javap</strong>——JDK自带的反编译器，可以查看生成的字节码，从而了解编译器内部的工作机制</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1572614300130.png\" alt=\"1572614300130\" class=\"article-img\"></p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1572614483662.png\" alt=\"1572614483662\" class=\"article-img\"></p>\n<h5 id=\"1-3-问题三：为什么JVM不直接将源码解析成机器码去执行\">1.3 问题三：为什么JVM不直接将源码解析成机器码去执行<a href=\"post/Java面试#1-3-问题三：为什么JVM不直接将源码解析成机器码去执行\"></a></h5><ul>\n<li>避免每次执行前都需要各种检查</li>\n<li>兼容性，也可以将其他语言解析成字节码</li>\n</ul>\n<p>若JVM直接将源码解析成机器码去执行，则每次执行前都需进行各种语法、句法、语义的检查(且不会被保存)，性能大大受到影响</p>\n<h5 id=\"1-4-问题四：JVM如何加载-class文件\">1.4 问题四：JVM如何加载.class文件<a href=\"post/Java面试#1-4-问题四：JVM如何加载-class文件\"></a></h5><p><strong>主要通过Class Loader将符合其格式的class文件加载到内存中，经由Execution Engine解析class文件中的字节码，并提交给操作系统去执行。</strong></p>\n<p>Java虚拟机：是一种抽象化的计算机，通过在实际的计算机上仿真、模拟各种计算机功能来实现的。JVM有自己完善的硬件架构(如处理器、堆栈、寄存器等)，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码——字节码，即可在不同平台上运行</p>\n<p>JVM屏蔽底层操作系统平台的不同，并且减少基于原生语言开发的复杂性。只需虚拟机厂商在特定操作系统上实现虚拟机定义如何将字节码解析成本操作系统能够执行的二进制码。</p>\n<p><strong>JVM最值得学习的两点：1. JVM内存空间结构模型  2. GC</strong></p>\n<p><strong>JVM是内存中的虚拟机，即JVM中的存储就是内存！</strong></p>\n<p>JVM的架构</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1572616101746.png\" alt=\"1572616101746\" class=\"article-img\"></p>\n<ul>\n<li>Class Loader : 依据特定格式，加载class文件到内存中(JVM在内存中)</li>\n<li>Execution Engine : 对命令进行解析</li>\n<li>Native Interface(本地接口) : 融合不同开发语言的原生库为Java所用(Java的性能不及C和C++,主流的JVM也是基于C实现)</li>\n<li>Runtime Data Area : JVM内存空间结构模型。我们所写的程序都会被加载到这里，之后再开始运行</li>\n</ul>\n<p>Class Loader的作用：加载编译好的class文件到内存。Class Loader加载的文件有格式要求(无需深究)，只管加载符合格式要求的class文件。只要符合格式，就能加载。至于能否运行，则由Execution Engine负责。</p>\n<p>Execution Engine，又名解释器。负责对命令进行解析，解析之后提交到真正的操作系统中执行。</p>\n<h5 id=\"1-5-问题五：什么是反射\">1.5 问题五：什么是反射<a href=\"post/Java面试#1-5-问题五：什么是反射\"></a></h5><p>Java反射机制是在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>\n<p>理论性过强，列举常用的反射函数或写一个反射例子</p>\n<p>狂神Java反射</p>\n<h5 id=\"1-6-问题六：类从编译到执行的过程\">1.6 问题六：类从编译到执行的过程<a href=\"post/Java面试#1-6-问题六：类从编译到执行的过程\"></a></h5><ol>\n<li>编译器将xxx.java源代码编译为xxx.class字节码文件</li>\n<li>ClassLoader将字节码转换为JVM的Class<xxx>对象</xxx></li>\n<li>JVM利用Class<xxx>对象实例化为xxx对象</xxx></li>\n</ol>\n<h5 id=\"1-7-问题七：谈谈ClassLoader\">1.7 问题七：谈谈ClassLoader<a href=\"post/Java面试#1-7-问题七：谈谈ClassLoader\"></a></h5><p>ClassLoader在Java中有着非常重要的作用，它主要工作在Class装载的加载阶段，其主要作用是从系统外部获得Class二进制数据流。它是Java的核心组件，所有的Class都是有ClassLoader进行加载的，ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化等操作。</p>\n<p>classLoader是一个抽象类，提供了一些接口，用以自定义class的加载流程以及加载方式</p>\n<p>主要方法：loadClass</p>\n<p>通过该方法才能加载类以及给定类名返回该类的实例，找不到则抛出异常classNotFoundException</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"keyword\">boolean</span> resolve)</span><br><span class=\"line\">    <span class=\"comment\">//resolve默认为false</span></span><br></pre></td></tr></table></div></figure>\n\n<p>ClassLoader的种类：</p>\n<ul>\n<li><p>BootStrapClassLoader: C++编写，加载java自带的核心类库java.*(用户不可见)</p>\n</li>\n<li><p>ExtClassLoader: java编写，加载扩展类库javax.*(用户可见)</p>\n<p>加载路径：java.ext.dirs</p>\n<p>用到才会加载，并非一次性加载</p>\n</li>\n<li><p>APPClassLoader: java编写，加载ClassPath目录(程序所在目录/类路径)下的内容(用户可见)</p>\n<p>加载路径：java.class.path</p>\n</li>\n<li><p>自定义ClassLoader: java编写，定制化加载</p>\n</li>\n</ul>\n<blockquote>\n<p>用户可见：可以通过代码看见</p>\n<p>用户不可见：不可以通过代码看见，BootStrapClassLoader是用C++编写的</p>\n</blockquote>\n<p>自定义ClassLoader的实现：通过覆盖两个函数</p>\n<ol>\n<li>findClass：寻找class文件，包括如何读进二进制流并对其进行处理，继而返回一个class对象</li>\n<li>defineClass：定义一个类，传入的参数是一个byte[]数组，字节码文件就是以一个byte数组的形式传入</li>\n</ol>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Class&lt;?&gt; defineClass(<span class=\"keyword\">byte</span>[] b, <span class=\"keyword\">int</span> off, <span class=\"keyword\">int</span> len) <span class=\"keyword\">throws</span> ClassFormatException&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defineClass(<span class=\"keyword\">null</span>,b,off,len,<span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>findClass就是根据名称去加载.class字节码，然后调用defineClass去解析定义.class字节流并返回class对象</p>\n<p>自定义ClassLoaderDemo</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String path;  <span class=\"comment\">//加载路径</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String classLoaderName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyClassLoader</span><span class=\"params\">(String path, String classLoaderName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//super(parent);</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.path = path;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.classLoaderName = classLoaderName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于寻找类文件 </span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Class <span class=\"title\">findClass</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            b = loadClassData(name);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> defineClass(name,b,<span class=\"number\">0</span>,b.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//用于加载类文件</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] loadClassData(String name) <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        name = path + name + <span class=\"string\">\".class\"</span>;</span><br><span class=\"line\">        InputStream in = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        ByteArrayOutputStream out = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            in = <span class=\"keyword\">new</span> FileInputStream(<span class=\"keyword\">new</span> File(name));</span><br><span class=\"line\">            out = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((i = in. read()) != -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                out.write(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                in.close();</span><br><span class=\"line\">                out.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out.toByteArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>测试</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassLoadChecker</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class=\"line\">        MyClassLoader m = <span class=\"keyword\">new</span> MyClassLoader(<span class=\"string\">\"E:\\\\IDEA-WorkSpace\\\\Basic-Java\\\\src\\\\\"</span>,<span class=\"string\">\"myClassLoader\"</span>);    </span><br><span class=\"line\">        <span class=\"comment\">//src后一定要有\\\\否则报错，因为name = path + name + \".class\";</span></span><br><span class=\"line\">        <span class=\"comment\">//\"\\\\是转义\"</span></span><br><span class=\"line\">        Class c = m.loadClass(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">        System.out.println(c.getClassLoader());</span><br><span class=\"line\">        c.newInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>要先用javac命令编译生成.class文件，否则找不到文件，无法转化成二进制流读入！</p>\n<p>findClass寻找到类文件后，就会将其以二进制byte[]数组的形式加载并传递给defineClass。</p>\n<h5 id=\"1-8-问题八：双亲委派机制\">1.8 问题八：双亲委派机制<a href=\"post/Java面试#1-8-问题八：双亲委派机制\"></a></h5><p>不同的ClassLoader加载类的方式和路径不同。加载类时会按照管理的区域各司其职，双亲委派机制就是让它们相互协作，形成整体的一种机制。</p>\n<p>双亲委派机制原理图</p>\n<p><img src=\"https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1572949872&di=164f71a0bcf42946dc62e24054ed345a&src=http://img2018.cnblogs.com/blog/1652057/201904/1652057-20190422161748156-1592156695.png\" alt=\"img\" class=\"article-img\"></p>\n<p>加载方式：</p>\n<p>首先，自底而上，从自定义ClassLoader开始查找是否加载过该类，若加载过则直接返回，若未加载则委派给APPClassLoader查找是否加载过该类</p>\n<p>重复上述过程直至找到BootStrapClassLoader</p>\n<p>若仍未找到，则BootStrapClassLoader就会尝试到Load JRE\\lib\\rt.jar或-Xbootclasspath指定路径下寻找是否有该类对应的文件。若有，则将文件加载进BootStrapClassLoader中并返回。若没有，则会从上往下委派给Extension ClassLoader去到对应的Load JRE\\lib\\ext\\*.jar或-Djava.ext.dirs指定路径下寻找是否有该类对应的文件。</p>\n<p>重复上述过程直至找到自定义ClassLoader</p>\n<p>ClassLoader中的loadClass源码：</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Loads the class with the specified &lt;a href=\"#name\"&gt;binary name&lt;/a&gt;.  The</span></span><br><span class=\"line\"><span class=\"comment\"> * default implementation of this method searches for classes in the</span></span><br><span class=\"line\"><span class=\"comment\"> * following order:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;ol&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   &lt;li&gt;&lt;p&gt; Invoke &#123;<span class=\"doctag\">@link</span> #findLoadedClass(String)&#125; to check if the class</span></span><br><span class=\"line\"><span class=\"comment\"> *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class=\"doctag\">@link</span> #loadClass(String) &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method</span></span><br><span class=\"line\"><span class=\"comment\"> *   on the parent class loader.  If the parent is &lt;tt&gt;null&lt;/tt&gt; the class</span></span><br><span class=\"line\"><span class=\"comment\"> *   loader built-in to the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class=\"doctag\">@link</span> #findClass(String)&#125; method to find the</span></span><br><span class=\"line\"><span class=\"comment\"> *   class.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/ol&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt; If the class was found using the above steps, and the</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;tt&gt;resolve&lt;/tt&gt; flag is true, this method will then invoke the &#123;<span class=\"doctag\">@link</span></span></span><br><span class=\"line\"><span class=\"comment\"> * #resolveClass(Class)&#125; method on the resulting &lt;tt&gt;Class&lt;/tt&gt; object.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt; Subclasses of &lt;tt&gt;ClassLoader&lt;/tt&gt; are encouraged to override &#123;<span class=\"doctag\">@link</span></span></span><br><span class=\"line\"><span class=\"comment\"> * #findClass(String)&#125;, rather than this method.  &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt; Unless overridden, this method synchronizes on the result of</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #getClassLoadingLock &lt;tt&gt;getClassLoadingLock&lt;/tt&gt;&#125; method</span></span><br><span class=\"line\"><span class=\"comment\"> * during the entire class loading process.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  name</span></span><br><span class=\"line\"><span class=\"comment\"> *         The &lt;a href=\"#name\"&gt;binary name&lt;/a&gt; of the class</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  resolve</span></span><br><span class=\"line\"><span class=\"comment\"> *         If &lt;tt&gt;true&lt;/tt&gt; then resolve the class</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span>  The resulting &lt;tt&gt;Class&lt;/tt&gt; object</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span>  ClassNotFoundException</span></span><br><span class=\"line\"><span class=\"comment\"> *          If the class could not be found</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"keyword\">boolean</span> resolve)</span><br><span class=\"line\">    <span class=\"keyword\">throws</span> ClassNotFoundException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//同步锁，防止多个线程调用同一个ClassLoader加载同一个类，避免冲突</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// First, check if the class has already been loaded</span></span><br><span class=\"line\">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> t0 = System.nanoTime();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    c = parent.loadClass(name, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ClassNotFoundException thrown if class not found</span></span><br><span class=\"line\">                <span class=\"comment\">// from the non-null parent class loader</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If still not found, then invoke findClass in order</span></span><br><span class=\"line\">                <span class=\"comment\">// to find the class.</span></span><br><span class=\"line\">                <span class=\"keyword\">long</span> t1 = System.nanoTime();</span><br><span class=\"line\">                c = findClass(name);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// this is the defining class loader; record the stats</span></span><br><span class=\"line\">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class=\"line\">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class=\"line\">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">            resolveClass(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>通过c.getClassLoader().getParent()方法可以得到加载类的父类，从而可以证明APPClassLoader是CustomClassLoader的父类，ExtensionClassLoader是APPClassLoader的父类，而ExtensionClassLoader的父类是null(因为BootStrapClassLoader是C++编写的，无法得到)</p>\n<p>为什么使用双亲委派机制加载类？</p>\n<ul>\n<li>避免多份同样字节码的加载，内存是宝贵的，没必要保存相同的两个类对象(class对象)</li>\n</ul>\n<h5 id=\"1-9-问题九：类的加载方式\">1.9 问题九：类的加载方式<a href=\"post/Java面试#1-9-问题九：类的加载方式\"></a></h5><ul>\n<li><p>隐式加载：new</p>\n<p>程序在加载过程中遇到通过new方式生成对象时，隐式调用类加载器，加载对应的类到JVM中</p>\n</li>\n<li><p>显示加载：loadClass，forName等</p>\n<p>通过loadClass以及forName等方法。显示加载需要类。对于显示加载来讲，当获得class对象之后，要调用class对象的newInstance()方法来生成对象的实例。</p>\n</li>\n</ul>\n<p>隐式加载与显示加载的区别：通过new来隐式加载则无需调用类对象(class对象)的newInstance()方法即可获取对象的实例，并且new支持带参数的构造器生成对象实例，而class对象的newInstance()方法则不支持传入参数，需要通过反射调用构造器对象的newInstance()方法才能支持传入参数。</p>\n<h5 id=\"1-10-问题十：loadClass和forName的区别\">1.10 问题十：loadClass和forName的区别<a href=\"post/Java面试#1-10-问题十：loadClass和forName的区别\"></a></h5><p>相同点：都能在运行时对任意一个类知道该类的所有属性和方法，对任意一个对象都能调用它的任意属性和方法。</p>\n<p>需要先了解类装载的过程(之前是加载，加载是装载的一部分)——class对象的生成过程。</p>\n<p>Java类装载分为3步：</p>\n<ol>\n<li>加载：通过ClassLoader加载class字节码文件到内存中，并生成class对象(将这些静态数据转换成运行时数据区中方法区的类型数据，在运行时，数据堆区中生成一个代表这个类的java.lang.class对象，作为方法区类数据的访问入口)。</li>\n<li>链接：<ul>\n<li>校验：检查加载的class文件的正确性和安全性。检查class文件的格式是否正确。</li>\n<li>准备：为类变量分配存储空间并设置类变量初始值。类变量随类型信息存放在方法区中，生命周期很长，使用不当很容易造成内存泄漏。类变量指的是static变量。初始值指的是类变量类型的默认值，而非实际赋予的值</li>\n<li>解析(可选)：JVM将常量池内的符号引用转换为直接引用</li>\n</ul>\n</li>\n<li>初始化：执行类变量赋值和静态代码块</li>\n</ol>\n<blockquote>\n<p>loadClass类中的resolve参数就是决定是否去解析类(链接类)，默认为false</p>\n<p>forName类中的initialize参数表示是否初始化，传递值为true。即调用forName时就会初始化该类</p>\n</blockquote>\n<p>不同点：Class.forName得到的class是已经初始化完成的，ClassLoader.loadClass得到的class是还没有链接的。</p>\n<p>演示代码：</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> JVM6_5;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Robot</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHi</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"hello,my name is \"</span> + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"hello,moto\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//测试类</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> JVM6_5;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoadDifference</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        ClassLoader cl = Robot.class.getClassLoader();</span><br><span class=\"line\">        <span class=\"comment\">//运行结果为空白(什么都没有)</span></span><br><span class=\"line\">        Class c = Class.forName(<span class=\"string\">\"JVM6_5.Robot\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//控制台打印\"hello,moto\"。因为static代码块中的内容需要在初始化时执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>由此可证明Class.forName得到的class是已经初始化完成的，ClassLoader.loadClass得到的class是还没有链接的。</p>\n<p>forName的用处：连接数据库驱动</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class.forName(<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>在Driver中有一段静态代码，因此只有调用forName才能执行</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.mysql.jdbc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.sql.DriverManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.sql.SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver</span> <span class=\"keyword\">extends</span> <span class=\"title\">NonRegisteringDriver</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">sql</span>.<span class=\"title\">Driver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Driver</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            DriverManager.registerDriver(<span class=\"keyword\">new</span> Driver());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException var1) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Can't register driver!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>loadClass的用处：在Spring IOC中，在资源加载器获取要读入的资源及读入bean的配置文件时，需要使用ClassLoader.loadClass加载。因为Spring IOC的lazy loading(延迟加载)。Spring IOC为了加快初始化速度，大量使用了延迟技术。而使用loadClass不需要执行类中的初始化代码以及链接的步骤，加快了装载速度，将类的初始化留到实际使用到该类时再做。</p>\n<h5 id=\"1-11-问题十一：什么是Java内存模型\">1.11 问题十一：什么是Java内存模型<a href=\"post/Java面试#1-11-问题十一：什么是Java内存模型\"></a></h5><p>内存简介：</p>\n<p>计算机的所有程序都是在内存中运行的。内存包括虚拟内存，也包括硬盘这样的外存支持。在程序运行过程中，需要不断将内存的虚拟地址和物理地址进行映射，找到相关的指令以及数据去执行。Java程序运行时面临和其他进程相同的内存限制，即受限于操作系统架构提供的可寻址地址空间。操作系统架构提供的可寻址地址空间由处理器的位数决定。常见的处理器有32位和64位。32位处理器提供了2^32的可寻址范围(大约4GB)，64位处理器提供了2^64的可寻址范围。</p>\n<p>地址空间的划分：</p>\n<ul>\n<li><p>内核空间</p>\n<p>主要的操作系统程序和C运行时的空间，包含用于连接计算机硬件、调度程序以及提供联网和虚拟内存等服务的逻辑和基于C的进程。</p>\n</li>\n<li><p>用户空间</p>\n<p>除内核空间之外的空间</p>\n<p>Java进程实际运行时使用的内存空间。32位系统用户进程最大可访问3GB，内核代码可访问所有物理内存。64位系统用户进程最大可访问超过512GB，内核代码可访问所有物理内存。</p>\n</li>\n</ul>\n<p>JVM内存模型——JDK8</p>\n<p>Java程序运行在虚拟机之上，运行时需要内存空间。虚拟机执行Java程序过程中会将其管理的内存划分为不同的数据区以方便管理。</p>\n<p>C编译器将内存区域划分为数据段和代码段，数据段包括堆、栈以及静态数据区。Java语言中将内存区域划分为线程共有和私有。</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573132587108.png\" alt=\"1573132587108\" class=\"article-img\"></p>\n<ol>\n<li><p>程序计数器(Program Counter Register)</p>\n<ul>\n<li>当前线程所执行的字节码行号指示器(逻辑)</li>\n<li>改变计数器的值来选取下一条需要执行的字节码指令</li>\n<li>和线程是一对一的关系即”线程私有”</li>\n<li>对Java方法计数，若是native方法则计数器值为undefined</li>\n<li>不会发生内存泄漏</li>\n</ul>\n<p>是一块较小的内存空间。作用是当前线程所执行的字节码行号指示器。在虚拟机的概念模型中，字节码解释器工作是通过改变计数器的值来选取下一条需要执行的字节码指令。由于JVM的多线程是通过线程轮流切换的，并分配处理器执行时间的方式来实现的，在任一确认的时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后恢复到正确的位置，每条线程都需要一个独立的程序计数器与之对应。各条线程的计数器之间各不影响，独立存储，称其这类内存为线程私有的内存。若线程正在执行Java方法，则该计数器记录正在执行虚拟机字节码指令的地址。如果是native方法则计数器值为undefined。此外，由于只是记录行号，程序计数器不会发生内存泄漏的问题。</p>\n<p>程序计数器是逻辑计数器而非物理计数器，为确保线程切换后都能恢复正确的执行位置，每个线程都有一个独立的程序计数器，程序计数器是线程独立的，且只为Java方法计数，且不会发生内存泄漏</p>\n</li>\n<li><p>Java虚拟机栈(Stack)</p>\n<ul>\n<li><p>Java方法执行的内存模型</p>\n</li>\n<li><p>包含多个栈帧</p>\n<p>Java虚拟机栈也是线程私有的，可以说是Java方法执行的内存模型，每个方法被执行时都会创建一个栈帧，即方法运行期间的基础数据结构。栈帧用于存储局部变量表、操作栈、动态连接、方法出口等每个方法执行中对应虚拟机栈帧从入栈到出栈的过程。Java虚拟机栈用来存储栈帧，栈帧持有局部变量和部分结果以及参与方法的调用与返回。当方法调用结束时，帧才会销毁。虚拟机栈包含了单个线程每个方法执行的栈帧，栈帧则存储了局部变量表，操作数栈、动态连接和方法出口等信息。</p>\n</li>\n</ul>\n</li>\n<li><p>本地方法栈</p>\n<p>与虚拟机栈相似，主要用于标注native方法</p>\n<p>Java方法调用虚拟机栈，带有native关键字的方法调用本地方法栈</p>\n</li>\n</ol>\n<p>局部变量表和操作数栈的区别：</p>\n<ul>\n<li><p>局部变量表：包含方法执行过程中的所有变量</p>\n</li>\n<li><p>操作数栈：包含入栈、出栈、复制、交换、产生消费变量</p>\n<p>在执行字节码指令过程中用到，这种方式类似原生CPU寄存器。大部分JVM字节码把时间花费在操作数栈的操作上，包括入栈、出栈、复制、交换、产生消费变量</p>\n</li>\n</ul>\n<p>因此，局部变量和操作数栈之间的交换变量指令操作通过字节码频繁执行。栈是一个后进先出的数据结构，因此，当前执行的方法在栈的顶部，每次方法调用时，一个新的栈帧创建并压栈到栈顶(?)，方法正常返回或抛出未捕获的异常时，栈帧就会出栈。除了栈帧的压栈和出栈之外，栈不能被直接操作。</p>\n<p>可以通过javap -verbose xxx.java 指令：用口语化的形式描述xxx.java文件</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ByteCodeSample</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">        c = a + b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573136450860.png\" alt=\"1573136450860\" class=\"article-img\"></p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573136192243.png\" alt=\"1573136192243\" class=\"article-img\"></p>\n<p>由上图可知操作数栈大小为2，局部变量表大小为3，一整个长方形条代表一个栈帧，共有7个栈帧。虚拟机栈会按照程序计数器从大到小依次压入栈帧，执行时也按照从小到大执行。</p>\n<p>首先，会执行iconst_0：将int值0压入操作数栈中，同时，传入的参数是1和2，因此局部变量表中就有2个变量，分别为1(第0个变量)和2(第1个变量)。</p>\n<p>接下来执行istore_2：将操作数栈中的栈顶元素0 pop出来存入局部变量表中的第2个变量中，此时，局部变量表中有3个变量。</p>\n<p>iload_0：将局部变量表中的第0个元素压入操作数栈中</p>\n<p>load——入栈 store——出栈</p>\n<p>iload_1：将局部变量表中的第1个元素压入操作数栈中，同时之前放入的1就会被挤到栈底</p>\n<p>iadd：将2和1弹出，将运算后的结果重新压入操作数栈中</p>\n<p>istore_2：将栈顶的元素3弹出存入到局部变量列表中的第2个变量中(替换掉0)</p>\n<p>iload_2：将局部变量列表中的第2个变量再次压入操作数栈顶</p>\n<p>ireturn：将栈顶元素返回</p>\n<p>方法完成执行，上述栈帧被自动销毁</p>\n<p>由此可知，局部变量列表主要是为操作数栈提供必要的数据支撑</p>\n<h5 id=\"1-12-问题十二：递归为什么会引发java-lang-StackOverflowError异常\">1.12 问题十二：递归为什么会引发java.lang.StackOverflowError异常<a href=\"post/Java面试#1-12-问题十二：递归为什么会引发java-lang-StackOverflowError异常\"></a></h5><p><strong>递归过深，栈帧数超出虚拟机栈深度</strong></p>\n<p>复现java.lang.StackOverflowError异常:</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackOverflowError</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">fibonacci</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fibonacci(n-<span class=\"number\">1</span>) + fibonacci(n-<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(fibonacci(<span class=\"number\">1000000</span> ));</span><br><span class=\"line\">        <span class=\"comment\">//递归过多</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Exception in thread \"main\" java.lang.StackOverflowError</span></span><br><span class=\"line\"><span class=\"comment\">\tat JVM6_11.StackOverflowError.fibonacci(StackOverflowError.java:9)</span></span><br><span class=\"line\"><span class=\"comment\">\tat JVM6_11.StackOverflowError.fibonacci(StackOverflowError.java:9)</span></span><br><span class=\"line\"><span class=\"comment\">\tat JVM6_11.StackOverflowError.fibonacci(StackOverflowError.java:9)</span></span><br><span class=\"line\"><span class=\"comment\">\tat JVM6_11.StackOverflowError.fibonacci(StackOverflowError.java:9)</span></span><br><span class=\"line\"><span class=\"comment\">\tat JVM6_11.StackOverflowError.fibonacci(StackOverflowError.java:9)</span></span><br><span class=\"line\"><span class=\"comment\">\tat JVM6_11.StackOverflowError.fibonacci(StackOverflowError.java:9)</span></span><br><span class=\"line\"><span class=\"comment\">\tat JVM6_11.StackOverflowError.fibonacci(StackOverflowError.java:9)</span></span><br><span class=\"line\"><span class=\"comment\">\tat JVM6_11.StackOverflowError.fibonacci(StackOverflowError.java:9)</span></span><br><span class=\"line\"><span class=\"comment\">\tat JVM6_11.StackOverflowError.fibonacci(StackOverflowError.java:9)</span></span><br><span class=\"line\"><span class=\"comment\">\tat JVM6_11.StackOverflowError.fibonacci(StackOverflowError.java:9)</span></span><br><span class=\"line\"><span class=\"comment\">\tat JVM6_11.StackOverflowError.fibonacci(StackOverflowError.java:9)</span></span><br><span class=\"line\"><span class=\"comment\">\tat JVM6_11.StackOverflowError.fibonacci(StackOverflowError.java:9)</span></span><br><span class=\"line\"><span class=\"comment\">\t......</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></div></figure>\n\n<p>产生原因分析：递归程序过多</p>\n<p>当线程执行一个方法时，就会随之创建一个栈帧并将建立的栈帧压入虚拟机栈中，当方法执行完毕后，就会将栈帧出栈。由此可知，线程当前执行的方法所对应的栈帧一定位于Java栈的顶部。而递归函数不断调用自身，每一次调用会涉及：</p>\n<ol>\n<li>每需调用方法就会生成一个栈帧</li>\n<li>会保存当前方法的栈帧状态，将其放入虚拟机栈中</li>\n<li>栈帧上下文切换时会切换到最新的方法栈帧中</li>\n</ol>\n<p>由于每个线程的虚拟机栈深度固定，递归实现将导致栈深度的增加，每次递归都会往栈中压入一个栈帧。当消耗超出了最大允许的深度，就会报java.lang.StackOverflowError异常。</p>\n<p>解决思路：限制递归的次数或直接使用循环替换递归</p>\n<h5 id=\"1-13-问题十三：为什么会引发java-lang-OutOfMemoryError异常\">1.13 问题十三：为什么会引发java.lang.OutOfMemoryError异常<a href=\"post/Java面试#1-13-问题十三：为什么会引发java-lang-OutOfMemoryError异常\"></a></h5><p><strong>虚拟机栈过多会引发java.lang.OutOfMemoryError异常</strong></p>\n<p>当虚拟机栈处于动态扩展时，若无法申请足够多的内存，就会抛出上述异常</p>\n<p>复现上述异常:</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stackLeakByThread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">        newThread()&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Exception in thread \"main\" java.lang.OutOfMemoryError:unable to create new native thread</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></div></figure>\n\n<p><strong>Windows平台虚拟机Java线程映射到操作系统的内核线程上，执行上述代码会导致系统假死。运行需谨慎</strong></p>\n<p><strong>小结：</strong></p>\n<p>虚拟机栈也是Java虚拟机自动管理的，栈类似一个集合，但是有固定容量，是由多个栈帧合起来的，在编写代码时每调用一个方法，在运行时Java虚拟机就会自动在内存中分配对应的一块空间(就是栈帧)，方法结束后，对应的栈帧就会自动的被释放掉，即栈的内存不需要通过GC回收</p>\n<h5 id=\"1-14-问题十四：元空间-MetaSpace-与永久代-PermGen-的区别\">1.14 问题十四：元空间(MetaSpace)与永久代(PermGen)的区别<a href=\"post/Java面试#1-14-问题十四：元空间-MetaSpace-与永久代-PermGen-的区别\"></a></h5><p>元空间(MetaSpace)：在JDK8以后类的元数据放在本地堆内存中的区域(JDK7及以前属于永久代)</p>\n<p>元空间和永久代都是用来存储class对象的相关信息，包括class对象的method和field。元空间和永久代都是方法区的实现(实现方法不同而已)。方法区是JVM的一种规范。Java 7之后，原先位于方法区中的字符串常量池被移到Java堆中，并且在Java 8之后，使用元空间替换了永久代。</p>\n<ul>\n<li><p>元空间使用本地内存，永久代使用的是JVM的内存</p>\n<p>使用本地内存的好处：java.lang.OutOfMemoryError:PermGen space异常将不复存在。因为默认的类的元数据分配只受本地内存大小的限制，即本地内存剩多少，理论上元空间就可以有多大，解决了空间不足的问题。但也不能放任无限壮大，JVM默认运行时根据需要动态设置其大小</p>\n</li>\n</ul>\n<p>元空间(MetaSpace)相比永久代(PermGen)的优势：</p>\n<ul>\n<li><p>字符串常量池存在永久代中容易出现性能问题和内存溢出(参考下例)</p>\n</li>\n<li><p>类和方法的信息大小难以确定，给永久代的大小指定带来困难。太小，容易导致永久代溢出，太大容易导致老年代溢出</p>\n</li>\n<li><p>永久代会为GC带来不必要的复杂性，并且回收效率较低。在永久代中，元数据可能会随着每一次Full GC发生而移动。HotSpot虚拟机中的每一种垃圾回收机制都需要特殊处理永久代中的元数据，分离出来之后可以简化Full GC以及对以后的并发隔离元数据方面进行优化</p>\n</li>\n<li><p>方便HotSpot与其他JVM如Jrockit的集成</p>\n<p>Oracle可能会将HotSpot和Jrockit合二为一，永久代是HotSpot JVM特有的，别的没有永久代这一说法。</p>\n</li>\n</ul>\n<p>用元空间替代能较好解决上述四个问题。</p>\n<p>只需重点记住<strong>元空间和永久代之间的区别是元空间内存使用的等额的本机内存，并且元空间没有了字符串常量池(在JDK 7时已移动到堆中)。MetaSpace其他存储的东西，包括类文件在JVM运行时的数据结构以及class相关的内容(method,field)大体上与永久代一样，只是划分上更加合理。比如说，类及相关的元数据的生命周期与类加载器一致，每个加载器(ClassLoader)都会分配一个单独的存储空间。</strong></p>\n<h5 id=\"1-15-问题十五：什么是Java堆\">1.15 问题十五：什么是Java堆<a href=\"post/Java面试#1-15-问题十五：什么是Java堆\"></a></h5><p>Java堆(Heap)</p>\n<ul>\n<li><p>对象实例的分配区域</p>\n<p>对于大多数应用来说，Java堆即Java Heap是Java虚拟机所管理的内存中最大的一块。Java堆是被所有的线程所共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573290863634.png\" alt=\"1573290863634\" class=\"article-img\"></p>\n<p>上图为32位处理器的Java进程的内存布局。从图中可以看出：可寻址的地址空间共有4GB，OS和C运行时大约占用其中1GB，JVM本身也需占用内存，Java堆占用了大约2GB，本机堆(native heap)则占用了剩余部分。根据Java虚拟机规范，Java虚拟机可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。既可实现成固定大小，也可以是可扩展的(主流的虚拟机都是按照可扩展实现的)。通过-Xmx,-Xms控制。若在堆中没有内存完成实例分配，且堆也无法再扩展时，将会抛出java.lang.OutOfMemoryError。</p>\n</li>\n</ul>\n<h5 id=\"找一下64位的！\"><strong>找一下64位的！</strong><a href=\"post/Java面试#找一下64位的！\"></a></h5><ul>\n<li><p>GC管理的主要区域</p>\n<p>Java堆也是GC管理的主要区域，因此也被称为GC堆。从内存回收的角度看，由于现在垃圾收集器基本都是采用分代收集算法，所以Java堆中还可细分为新生代和老年代。再细致分为</p>\n<ul>\n<li>Eden</li>\n<li>survivor：分为from survivor和to survivor</li>\n<li>tenured</li>\n</ul>\n<p>(详情见Java垃圾回收)</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573291641950.png\" alt=\"1573291641950\" class=\"article-img\"></p>\n</li>\n</ul>\n<h5 id=\"以下从存储的角度学习五个部分\">以下从存储的角度学习五个部分<a href=\"post/Java面试#以下从存储的角度学习五个部分\"></a></h5><h5 id=\"1-16-问题十六：JVM三大性能调优参数-Xms-Xmx-Xss的含义\">1.16 问题十六：JVM三大性能调优参数 -Xms -Xmx -Xss的含义<a href=\"post/Java面试#1-16-问题十六：JVM三大性能调优参数-Xms-Xmx-Xss的含义\"></a></h5><p>例：java -Xms128m -Xmx128m -Xss256k -jar xxxx.jar</p>\n<p>调用Java指令执行程序时，可以通过传入以上三个参数去调整Java的堆以及线程所占内存的大小。</p>\n<ul>\n<li><p>-Xss：规定了每个线程虚拟机栈(堆栈)的大小</p>\n<p>一般情况下，256k足够。此配置会影响此进程中并发线程数的大小</p>\n</li>\n<li><p>-Xms：堆的初始值</p>\n<p>初始的Java堆的大小，即该进程刚创建时专属Java堆的大小，一旦对象容量超过了Java堆的初始容量，Java堆将会自动扩容，扩容至-Xmx大小</p>\n</li>\n<li><p>-Xmx：堆能达到的最大值</p>\n<p>Java堆能扩容的最大值。在很多情况下，将-Xms -Xmx设置成一样的。因为，当Heap不够用而发生扩容时，会发生内存抖动影响程序运行时的稳定性</p>\n</li>\n</ul>\n<h5 id=\"1-17-问题十七：Java内存模型中堆和栈的区别\">1.17 问题十七：Java内存模型中堆和栈的区别<a href=\"post/Java面试#1-17-问题十七：Java内存模型中堆和栈的区别\"></a></h5><p>堆——堆</p>\n<p>栈——堆栈，本机虚拟机堆栈</p>\n<p>要先了解程序运行时的内存分配策略</p>\n<p>程序运行时有3种分配策略：静态、堆式、栈式</p>\n<ul>\n<li><p>静态存储：编译时确定每个数据目标在运行时的存储空间需求，因而在编译时就可以给他们分配固定的内存空间。这种分配策略，要求程序代码中不允许有可变数据结构的存在，也不允许有嵌套或者递归的结构出现。因为它们都会导致程序无法计算准确的存储空间。</p>\n</li>\n<li><p>栈式存储：数据区需求在编译时未知，运行时模块入口前确定</p>\n<p>该分配可称为动态的存储分配，是由一个类似于堆栈的运行栈实现的，和静态存储的分配方式相反，在栈式存储方案中，程序对数据区的要求在编译时未知，只有运行时才能知道。规定在运行中进入一个程序模块时必须知道该程序模块所需数据区的大小才能分配其内存。和数据结构中的栈一样，栈式存储按照先进后出的原则进行分配</p>\n</li>\n<li><p>堆式存储：编译时或运行时模块入口都无法确定，动态分配</p>\n<p>专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配，比如可变长度串和对象实例。堆由大片的可利用块或空闲块组成，堆中的内存可按照任意顺序分配和释放</p>\n</li>\n</ul>\n<p>堆和栈的联系：创建好的数组和对象实例都会被保存在堆中，想要引用堆中的某个对象或者数组，想要在栈中定义一个变量，使其取值为数组或者对象在堆内存中的首地址。栈中的变量就成为数组或者对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后就会被释放掉，而数组和对象本身在堆中分配，即使程序运行到使用new产生数组或对象的代码块之外，数组和对象占据的内存也不会被释放。只有在没有引用变量指向时，才会变为垃圾，需要等待随后的一个不确定时间被垃圾回收器释放掉。</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573044786338.png\" alt=\"1573044786338\" class=\"article-img\"></p>\n<p>由图可知，在调用new Person()时，会在堆内存中创建出相关的对象实例，同时将其首地址赋值给p并保存在当前线程虚拟机栈内存中。通过获取变量p中保存的对象实例的地址，便能轻松调用到保存在堆的Person对象的实例</p>\n<p>区别：</p>\n<ul>\n<li><p>管理方式：栈自动释放，堆需要GC</p>\n<p>JVM自己可以针对内存栈进行管理操作，而且该内存空间的释放是编译器就可以操作的内容，而堆空间在Java中，JVM执行引擎不会对其进行释放操作，而是让垃圾回收器进行自动回收</p>\n</li>\n<li><p>空间大小：栈比堆小</p>\n<p>一般情况下，栈空间对于堆空间比较小。这是由栈空间里面存储的数据以及本身需要的数据特性决定的，而堆空间在JVM对实例进行分配时一般大小都比较大，因为堆空间在一个Java程序中需要存储比较多的Java对象数据</p>\n</li>\n<li><p>碎片相关：栈产生的碎片远小于堆</p>\n<p>针对堆空间而言，即使垃圾回收器能够进行自动堆内存回收，但是堆空间的活动量相对于栈空间而言比较大，很有可能存在长期的堆空间分配和释放操作。而且垃圾回收器不是实时的，可能使得堆空间的内存碎片逐渐累积起来。针对栈空间而言，因其本身就是一个栈的数据结构，操作都是一一对应的，并且每一个最小单位的结构栈帧和堆空间内复杂的内存结构不同，所以在使用过程中很少出现内存碎片</p>\n</li>\n<li><p>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</p>\n<p>一般情况下，栈空间有两种分配方式：静态和动态分配。静态分配是本身由编译器分配好，而动态分配可能根据情况有所不同。堆空间确是完全的动态分配，是一个运行时级别的内存。而栈空间分配的内存不需要考虑释放的问题，堆空间在即使有垃圾回收器的前提下还是要考虑释放的问题</p>\n</li>\n<li><p>效率：栈的效率比堆高</p>\n<p>因为内存块本身的排列就是一个典型的堆栈结构，所以栈空间的效率比起堆空间要高很多，并且计算机底层内存空间本身使用了最基础的堆栈结构，使得栈空间和底层结构更加符合，使其操作也变得简单。只涉及到2个指令：入栈和出栈</p>\n</li>\n</ul>\n<p>栈空间针对堆空间而言的不足是灵活程度不够，特别是在动态管理时。而堆空间最大的优点在于动态分配。因为在计算机底层实现可能是一个双向链表的结构，所以在管理时操作比栈空间复杂很多，灵活度自然就高了，但是这样的设计使得堆空间的效率不如栈空间，并且低很多</p>\n<h5 id=\"1-18-问题十八：从存储角度，将堆、meta-space-元空间-以及线程独占的部分间的联系\">1.18 问题十八：从存储角度，将堆、meta space(元空间)以及线程独占的部分间的联系<a href=\"post/Java面试#1-18-问题十八：从存储角度，将堆、meta-space-元空间-以及线程独占的部分间的联系\"></a></h5><figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello\"</span> + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">        Hello hello = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">        hello.setName(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">        hello.sayHello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>各部分存储情况如下：</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573048160827.png\" alt=\"1573048160827\" class=\"article-img\"></p>\n<p>当类被加载进来时，元空间保存Hello这个装载进来的class对象的信息以及Method(方法)：sayHello\\setName\\main以及name这个Field，额外的还有System这个类对象以及该类中的成员变量和方法。</p>\n<p>当Hello被创建时，堆中主要存储的是Hello这个类创建出的对象实例Objective以及String(“test”)实例</p>\n<p>当程序执行时，即main线程会分配对应的虚拟机栈、本地栈以及程序计数器。栈中存有String类型的引用参数，对应与堆中的”test”字符串Object对应的地址引用，以及本地变量hello保存堆中Hello Object的地址引用，以及局部变量a保存1的值以及系统自带的lineNumber行号用来记录代码的执行，以方便对程序进行追踪</p>\n<h5 id=\"1-19-问题十九：不同版本之间的intern-方法的区别\">1.19 问题十九：不同版本之间的intern()方法的区别<a href=\"post/Java面试#1-19-问题十九：不同版本之间的intern-方法的区别\"></a></h5><p>主要讨论JDK6和JDK6以上的版本</p>\n<p>intern方法在JDK6中仅会在常量池中添加字符串对象，JDK6+既可以向常量池中添加字符串对象，也可以添加字符串在堆中的引用</p>\n<p>intern()是字符串的一个方法</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">\"a\"</span>).intern();</span><br></pre></td></tr></table></div></figure>\n\n<p>JDK6:当调用intern方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中该字符串的引用。否则，将此字符串对象添加到字符串常量池中，并且返回该字符串对象引用。</p>\n<p>JDK6+：当调用intern方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中该字符串的引用。否则，如果该字符串对象已经存在于Java堆中，则将堆中对此对象的引用添加到字符串常量池中，并且返回该引用(与堆中地址相同)；如果堆中不存在，则在池中创建该字符串并返回其引用。</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573050042052.png\" alt=\"1573050042052\" class=\"article-img\"></p>\n<p>Java7之后，方法区中的字符串常量池移动到Java堆中。主要原因：先前字符串常量池存在于永久代中，而永久代的内存极为有限，若频繁调用intern在池中创建字符串会使得字符串常量池被挤爆进而引发java.lang.OutOfMemoryError:PermGen space(永久代发生的异常)。JDK7之后将常量池移出永久代到Java堆中上述异常就会避免</p>\n<h4 id=\"2-GC考点\">2. GC考点<a href=\"post/Java面试#2-GC考点\"></a></h4><p><strong>Java虚拟机的作用(误，视频中没有自己瞎编)可以归结为自动化解决了两个问题。</strong></p>\n<ol>\n<li><strong>对象内存分配的问题</strong></li>\n<li><strong>回收分配给对象的内存的问题</strong></li>\n</ol>\n<p><strong>提高码农效率的垃圾回收机制，正因存在此机制，编写代码时才不必担心对象内存的释放问题，将其交由JVM管理</strong></p>\n<h5 id=\"2-1-对象被定义为垃圾的标准\">2.1 对象被定义为垃圾的标准<a href=\"post/Java面试#2-1-对象被定义为垃圾的标准\"></a></h5><ul>\n<li><p>没有被其他对象引用</p>\n<p>当没有被其他对象引用时，该对象就是没用的，对应系统而言就是垃圾，其占据的内存就会被释放，同时此对象也会被销毁。</p>\n</li>\n</ul>\n<h5 id=\"2-2-判定对象是否为垃圾的算法\">2.2 判定对象是否为垃圾的算法<a href=\"post/Java面试#2-2-判定对象是否为垃圾的算法\"></a></h5><h6 id=\"2-2-1-引用计数算法\">2.2.1 引用计数算法<a href=\"post/Java面试#2-2-1-引用计数算法\"></a></h6><p><strong>通过判断对象的引用数量来决定对象是否可以被回收</strong></p>\n<ul>\n<li><p>通过判断对象的引用数量来决定对象是否可以被回收</p>\n</li>\n<li><p>每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1</p>\n</li>\n<li><p>何引用计数为0的对象实例都可以被当做垃圾收集</p>\n<p>对于引用计数算法，<strong>通过判断对象的引用数量来决定对象是否可以被回收</strong>。在这种机制下，堆中的每个对象实例都有一个引用计数器，当一个对象被创建时，若该对象实例分配给一个引用变量，则+1。当该对象实例的某个引用超过了生命周期或被设置为新值时(表示引用完成)，该对象实例的引用计数器-1。任何引用计数为0的对象实例都可以被当做垃圾收集。</p>\n</li>\n</ul>\n<p>经过引用计数算法的判断后，当引用计数变为0时，对象就被视为垃圾。</p>\n<p><strong>优点：执行效率高，程序执行受影响较小</strong></p>\n<p>优势是可以很快执行。因为只需过滤出引用计数器为0的对象，将其内存回收即可，可以交织在程序中。由于垃圾回收的时候可以做到几乎不打断程序的执行，因此对程序需要不被长时间打断的实施环境有利。</p>\n<p><strong>缺点：无法检测出循环引用的情况，导致内存泄漏</strong></p>\n<p>由于实现过于简单，容易出现无法检测出循环引用的情况(如父对象对子对象有一个引用，子对象又反过来引用父对象，这样的引用永远不可能为0)</p>\n<p><strong>由于上述缺点，JVM采用可达性分析算法作为垃圾回收算法</strong></p>\n<h6 id=\"2-2-2-可达性分析算法\">2.2.2 可达性分析算法<a href=\"post/Java面试#2-2-2-可达性分析算法\"></a></h6><p><strong>通过判断对象的引用链是否可达来决定对象是否可以被回收</strong></p>\n<p>从离散数学图论中引出，程序将所有引用关系看作一张图，通过一系列名为GC root对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径就被称为引用链(即reference chain)，当一个对象从GC root没有任何引用链相连，从图论上来说即为从GC root到该对象不可达，从而证明该对象不可用，从而被标记为垃圾。</p>\n<p>垃圾回收器会对内存中的整个对象图进行遍历，从GC根(GC root)开始访问，根对象引用的其他对象，回收器将访问到的所有对象标为可达，剩下的即为GC root不可达的对象，也意味着这些对象不会被用到，为垃圾对象。回收器会在接下来的阶段中清除这些对象。</p>\n<p><strong>可以作为GC root的对象：</strong></p>\n<ul>\n<li><p><strong>虚拟机栈中引用的对象(栈帧中的本地变量表中引用的对象)</strong></p>\n<p>比如说在Java方法中new了一个Object并赋值给了一个局部变量，那么在该局部变量未被销毁之前new出的Object就是GC root</p>\n</li>\n<li><p><strong>方法区中的常量引用对象</strong></p>\n<p>比如在类中定义一个常量，而该常量保存的是某个对象的地址，那么被保存的对象也成为GC的根对象</p>\n</li>\n<li><p><strong>方法区中的类静态属性引用的对象</strong></p>\n<p>同第二种情况</p>\n</li>\n<li><p><strong>本地方法栈中的JNI(Native方法)的引用对象</strong></p>\n<p>调用native方法即被引用的通过非Java语言构建的对象也可以成为GC root</p>\n</li>\n<li><p><strong>活跃线程的引用对象</strong></p>\n<p>Java万物皆为对象，因此活跃的线程也会成为GC root，只要线程还处于活跃状态。</p>\n</li>\n</ul>\n<h5 id=\"2-3-问题一：谈谈你了解的垃圾回收算法\">2.3 问题一：谈谈你了解的垃圾回收算法<a href=\"post/Java面试#2-3-问题一：谈谈你了解的垃圾回收算法\"></a></h5><h6 id=\"2-3-1-标记-清除算法-Mark-and-Sweep\">2.3.1.标记-清除算法(Mark and Sweep)<a href=\"post/Java面试#2-3-1-标记-清除算法-Mark-and-Sweep\"></a></h6><p>将回收分为两个阶段：</p>\n<p><strong>标记：从根集合进行扫描，对存活的对象进行标记(可达性算法)</strong></p>\n<p><strong>清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存</strong></p>\n<p>该算法首先从根集合进行扫描，对存活的对象进行标记。使用可达性算法找到垃圾对象，标记完毕后会对堆内存从头到尾进行线性遍历，如果发现有对象未被标识为可达对象(即为不可达对象/垃圾对象)，就会对此对象占用的内存回收掉并且将原来标记为可达的对象的标识清除掉，以便进行下一次垃圾回收</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573306888282.png\" alt=\"1573306888282\" class=\"article-img\"></p>\n<p>如图所示，Mark阶段，BEFGJK均为可达对象，Sweep阶段，ACDHI都被回收掉了。</p>\n<p><strong>不足：碎片化</strong></p>\n<p>由于标记-清除算法不需要对象的移动，并且仅对不存活的对象进行处理。因此，标记-清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致之后程序在运行过程中需要分配较大对象时无法找到足够的内存而不得不提前触发另一次垃圾回收工作。</p>\n<h6 id=\"2-3-2-复制算法-Coping\">2.3.2 复制算法(Coping)<a href=\"post/Java面试#2-3-2-复制算法-Coping\"></a></h6><ul>\n<li>分为对象面和空闲面</li>\n<li>对象在对象面上创建</li>\n<li>存活的对象被从对象面复制到空闲面</li>\n<li>将对象面所有对象内存清除</li>\n</ul>\n<p>复制算法将可用的内存按容量按一定比例划分为两块或多块，并选择其中一块或两块作为对象面，其他的作为空闲面。对象主要在对象面上创建，当被定义为对象面的块的内存用完时，将还存活着的对象复制到其中一块空闲面，再将已使用过的内存空间一次清理掉。</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573308138138.png\" alt=\"1573308138138\" class=\"article-img\"></p>\n<p><strong>适用对象存活率低的场景(年轻代)</strong></p>\n<p>这样，内存分配时就不用考虑内存碎片等复杂情况</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li><p><strong>解决碎片化问题</strong></p>\n</li>\n<li><p><strong>顺序分配内存，简单高效</strong></p>\n</li>\n<li><p><strong>适用于对象存活率低的场景</strong></p>\n</li>\n<li><p><strong>回收年轻代</strong></p>\n<p>研究证明，年轻代用到的对象每次回收都基本只有10%的对象存活，需要复制的对象很少，因此使用此种算法的效率还不错。</p>\n</li>\n</ul>\n<p><strong>缺点：不适用对象存活率高的场景</strong></p>\n<h6 id=\"2-3-3-标记-整理算法-Compacting\">2.3.3 标记-整理算法(Compacting)<a href=\"post/Java面试#2-3-3-标记-整理算法-Compacting\"></a></h6><p><strong>适合老年代</strong></p>\n<p>采用和标记-清除算法类似的方式：</p>\n<p><strong>标记：从根集合进行扫描，对存活的对象进行标记(可达性算法)</strong></p>\n<p><strong>清除：移动所有存活的对象，且按照内存地址次序依次排列，如何将末端内存地址以后的内存全部回收</strong></p>\n<p>在标记-清除算法的基础上进行了对象的移动，因此成本更高，但解决了内存碎片的问题。</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573353882049.png\" alt=\"1573353882049\" class=\"article-img\"></p>\n<p>先通过可达性算法确定存活对象和可回收的对象，回收时先将存活的对象压缩到内存的一端，再将除此之外的所有内存空间清除 。</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li><strong>避免内存的不连续行</strong></li>\n<li><strong>不用设置两块内存互换</strong></li>\n<li><strong>适用于存活率高的场景(老年代的回收)</strong></li>\n</ul>\n<h6 id=\"2-3-4-分代收集算法-Generation-Collector\">2.3.4 分代收集算法(Generation Collector)<a href=\"post/Java面试#2-3-4-分代收集算法-Generation-Collector\"></a></h6><p>主流垃圾回收算法</p>\n<ul>\n<li>垃圾回收算法的组合拳</li>\n<li>按照对象生命周期的不同划分区域采用不同的垃圾回收算法</li>\n<li>目的：提高JVM的回收效率</li>\n</ul>\n<p>分代收集算法将堆内存进一步划分，不同对象的生命周期及存活情况是不一样的。将不同生命周期的对象分配到堆中不同的区并对堆内存不同区域采用不同的回收策略，可以提高JVM垃圾回收的效率。</p>\n<p>JDK 7及之前，堆内存一般分为年轻代、老年代和永久代。</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573467559221.png\" alt=\"1573467559221\" class=\"article-img\"></p>\n<p>JDK 8及以后，取消了永久代。</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573467607068.png\" alt=\"1573467607068\" class=\"article-img\"></p>\n<p><strong>年轻代的对象存活率低，采用复制算法。</strong></p>\n<p><strong>老年代的对象存活率高，采用标记-清除算法/标记-整理算法。</strong></p>\n<p>分代收集算法的GC的分类：</p>\n<ul>\n<li><p>Minor GC</p>\n<p>是发生在年轻代中的垃圾收集动作，采用复制算法。年轻代几乎是所有Java对象出生的地方，即Java对象申请的内存及存放都在年轻代。Java中的大部分对象通常不需要长久的存活，具有朝生夕灭的特性，当一个对象被判定为死亡时，GC就有责任回收掉这部分对象的内存空间。新生代是GC收集垃圾的频繁区域。</p>\n</li>\n<li><p>Full GC</p>\n<p>与老年代相关。由于对于老年代的回收一般伴随着年轻代的收集，因此称为Full GC。(下节讲)</p>\n</li>\n</ul>\n<p><strong>年轻代：尽可能快速地收集掉那些生命周期短的对象</strong></p>\n<ul>\n<li><p>Eden区</p>\n<p>对象刚被创建时，其内存空间首先被分配到Eden区。若Eden区放不下，新创建的对象也可能会被放到Survivor区甚至是老年代中。</p>\n</li>\n<li><p>两个Survivor区</p>\n<p>被定义为from区和to区(不固定，会随着垃圾回收的进行而相互转换)</p>\n</li>\n</ul>\n<p>年轻代的目标就是尽可能快速地收集掉那些生命周期短的对象，一般情况下，新生成的对象首先都是放在年轻代中。年轻代的内存一般按照8:1:1的默认比例分为一个Eden区和两个Survivor区。绝大部分对象在Eden区中生成。年轻代中的对象大部分都是朝生夕死的，所以无需按照1:1:1的比例划分内存空间。而是将年轻代内存分为一个较大的Eden区和两块较小的Survivor区。每次使用Eden和其中一块Survivor区，当进行垃圾回收时，将Eden和使用着的Survivor区中存活着的对象一次性复制到还未使用的Survivor中，最后清理掉Eden和使用的Survivor区。当Survivor区不够用时，则需依赖老年代进行分配担保。</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573468613656.png\" alt=\"1573468613656\" class=\"article-img\"></p>\n<p>年轻代垃圾回收的过程演示：7-2的6‘40s处</p>\n<p>对象在Survivor区每熬过因此Minor GC，其年龄就会被+1。当对象的年龄达到某一值时(默认为15，可以通过参数-XX:MaxTenuringThreshold修改)，就会成为老年代。但也不是一定的，对于一些较大的对象(即需要分配一块较大的连续内存空间的对象)，Eden区和Survivor区装不下的对象，就会进入老年代。Minor GC采用复制算法，使得进行内存分配时无需考虑内存碎片这种复杂情况，只需移动堆顶指针按顺序分配即可，在回收时一次性将某个区清空，简单高效粗暴。</p>\n<p><strong>对象如何晋升到老年代：</strong></p>\n<ul>\n<li><p>经历一定的Minor次数依然存活的对象</p>\n<p>对象在新生代每经历一次Minor GC依然存活则年龄+1，当年龄超过一定限制就会放入老年代</p>\n</li>\n<li><p>Survivor区中存放不下的对象</p>\n<p>Survivor区或Eden区中放不下的对象会直接进入老年代。对象优先在Eden中分配，当Eden中没有足够空间分配时会触发一次Minor GC，每次Minor GC结束后，Eden区便会被清空，将Eden区中的内容复制到Survivor区，当Survivor区中放不下时则由分配担保进入老年代中</p>\n</li>\n<li><p>新生成的大对象(-XX:+PretenuerSizeThreshold)</p>\n<p>直接进入老年代中，可通过上述参数控制大对象的大小，超过size立马放入老年代中。</p>\n</li>\n</ul>\n<p>可以像设置永久代参数一样传入参数调整</p>\n<p><strong>常用的调优参数：</strong></p>\n<ul>\n<li>-XX:SurvivorRatio：Eden和其中一个Survivor的比值，默认为8:1</li>\n<li>-XX:NewRatio：老年代和年轻代内存大小的比例。若比例为2，则代表老年代的内存大小是年轻代的2倍。而老年代和年轻代内存大小总和是由-xmx和-xms决定的</li>\n<li>-XX:MaxTenuringThreshold：对象从年轻代晋升到老年代经过GC次数的最大阈值</li>\n</ul>\n<p><strong>老年代：存放生命周期较长的对象</strong></p>\n<p>老年代的内存要比年轻代大得多，大约为2:1。</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573471335129.png\" alt=\"1573471335129\" class=\"article-img\"></p>\n<p>原因：老年代对象存活率较高，且没有额外空间进行分配担保。</p>\n<p>当触发老年代的垃圾回收时，通常会伴随着年轻代堆内存的回收(即对整个堆进行垃圾回收，所以称为Full GC)</p>\n<p>Major GC和Full GC是等价的，即收集整个GC堆。HotSpot发展多年，外界对各种名词的解读混乱，提及Major GC时，一定要确认是Full GC还是仅仅针对老年代的GC</p>\n<p>Full GC的速度比Minor GC慢得多，一般慢10倍以上，但是执行频率低。</p>\n<p><strong>触发Full GC的条件：</strong></p>\n<ul>\n<li><p><strong>老年代空间不足</strong></p>\n<p>创建一个新对象，Eden区中放不下会直接保存在老年代中，若老年代空间也不足，就会触发Full GC。避免：不要创建太大的对象</p>\n</li>\n<li><p><strong>永久代空间不足</strong></p>\n</li>\n<li><p>仅针对JDK 7及以前的版本，当系统中需要加载的类，调用的方法很多同时永久代中没有足够的空间存放类信息和方法信息时，就会触发一次Full GC。JDK 8及以后取消永久代改用元空间代替，降低了Full GC的频率，减少GC的负担，提升其效率(使用元空间替代永久代的目的)</p>\n</li>\n<li><p><strong>调用System.gc()</strong></p>\n<p>程序中直接调用System.gc()方法，就会显式直接触发Full GC，同时对老年代和年轻代进行回收。<strong>注意：只是提醒虚拟机在此回收一下，但最后是否回收还是由虚拟机决定。即程序员对是否回收没有控制权</strong></p>\n</li>\n<li><p>CMS GC时出现promotion failed和concurrent mode failure</p>\n<p>对于采用CMS进行老年代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure这两种情况，当这两种情况出现时会触发Full GC。promotion failed是在进行Minor GC时Survivor区放不下，对象只能放入老年代，而此时老年代也放不下就会造成promotion failed。concurrent mode failure是在执行CMS GC的同时有对象要放入老年代中，而此时老年代空间不足就会造成该情况。</p>\n</li>\n<li><p>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</p>\n<p>统计得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间。这是一种非常复杂的触发情况。HotSpot为了避免由于年轻代对象晋升到老年代导致老年代空间不足的现象，在进行Minor GC时作了一个判断，若之前统计所得的Minor GC晋升到老年代的平均大小大于老年代的剩余空间，就直接触发Full GC</p>\n</li>\n<li><p>使用RMI(远程控制方式)来进行RPC或管理的JDK应用，默认每小时执行1次Full GC</p>\n</li>\n</ul>\n<h5 id=\"2-4-GC的优化\">2.4 GC的优化<a href=\"post/Java面试#2-4-GC的优化\"></a></h5><h6 id=\"2-4-1-Stop-the-World\">2.4.1 Stop-the-World<a href=\"post/Java面试#2-4-1-Stop-the-World\"></a></h6><ul>\n<li>JVM由于要执行GC而停止了应用程序的执行</li>\n<li>任何一种GC算法中都会发生</li>\n<li>大多数的GC优化就是指减少Stop-the-World发生的时间来提高程序性能</li>\n</ul>\n<p>Stop-the-World意味着JVM由于要执行GC而停止了应用程序的执行，并且会发生在任何一种GC算法中。当Stop-the-World发生时，除了GC所处的线程外，所有线程均处于等待状态直到GC任务完成。事实上，GC优化就是指减少Stop-the-World发生的时间从而使系统具有高吞吐低停顿的特点。</p>\n<h6 id=\"2-4-2-Safepoint\">2.4.2 Safepoint<a href=\"post/Java面试#2-4-2-Safepoint\"></a></h6><p>垃圾收集中的安全点(Safepoint)。</p>\n<ul>\n<li><p>分析过程中对象引用关系不会发生变化的点</p>\n<p>在可达性分析中要分析哪个对象没有被引用时需在一个快照(听不清)的状态点进行，在该点处，所有的线程都被冻结，不可以出现分析过程中对象引用关系还在不停变换的情况，因此分析结果需要在某个节点具有确定性，该节点便被叫做安全点。程序不是在顺便哪个点就停下来，而是达到安全点才会停顿下来。</p>\n</li>\n<li><p>产生安全点的地方：方法调用、循环跳转、异常跳转等。</p>\n<p>产生安全点的地方：方法调用、循环跳转、异常跳转等才会产生安全点。 一旦GC发生，让所有的线程都跑到最近的安全点再停顿下来。若发现线程不在安全点，就恢复线程等其跑到安全点再说。</p>\n</li>\n<li><p>安全点的数量适中。安全点的选择既不能太少也不能太多。太少会让GC等待时间长，太多会增加程序运行负荷。</p>\n</li>\n</ul>\n<h6 id=\"2-4-3-系统吞吐量\">2.4.3 系统吞吐量<a href=\"post/Java面试#2-4-3-系统吞吐量\"></a></h6><p>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p>\n<p>即CPU运行用户代码时间与CPU总消耗时间的比值</p>\n<h5 id=\"2-5-常见的垃圾收集器\">2.5 常见的垃圾收集器<a href=\"post/Java面试#2-5-常见的垃圾收集器\"></a></h5><h6 id=\"2-5-1-JVM的运行模式\">2.5.1 JVM的运行模式<a href=\"post/Java面试#2-5-1-JVM的运行模式\"></a></h6><ul>\n<li>Server</li>\n<li>Client</li>\n</ul>\n<p>两种模式的区别：Client启动较快，Server启动较慢。但是启动进入长期运行之后，Server模式的程序运行速度比Client快。因为Server模式启动的JVM是采用的是重量级的虚拟机，对程序采用了更多的优化，而Client模式启动的JVM采用的是轻量级的虚拟机，所以Server启动慢但稳定运行后速度快。</p>\n<p>查询当前JVM运行模式：java -version</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573479512404.png\" alt=\"1573479512404\" class=\"article-img\"></p>\n<h6 id=\"2-5-2常见的垃圾收集器\">2.5.2常见的垃圾收集器<a href=\"post/Java面试#2-5-2常见的垃圾收集器\"></a></h6><p>垃圾收集器是和具体JVM实现紧密相关</p>\n<p>垃圾收集器之间的联系</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573479725167.png\" alt=\"1573479725167\" class=\"article-img\"></p>\n<p>(有连线表明可搭配使用)</p>\n<p><strong>CMS与Parallel Scavenge收集器不兼容的原因：因为Parallel Scavenge(和G1)都未使用传统的GC收集器框架，而是另外的独立实现。其他收集器共用部分框架，因此兼容。</strong></p>\n<h6 id=\"2-5-3-年轻代常见的垃圾收集器\">2.5.3 年轻代常见的垃圾收集器<a href=\"post/Java面试#2-5-3-年轻代常见的垃圾收集器\"></a></h6><ul>\n<li><p>Serial收集器(-XX:+UseSerialGC，复制算法)</p>\n<ul>\n<li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li>\n<li>简单高效，CLient模式下默认的年轻代收集器</li>\n</ul>\n<p>在程序启动时通过设置-XX:+UseSerialGC使得年轻代使用该垃圾收集器回收。Serial收集器是Java虚拟机中最基本、历史最悠久的收集器。JDK1.3.1之前是Java虚拟机年轻代收集的唯一选择。Serial收集器是采用复制算法的单线程的垃圾收集器。但它单线程的意义并不只是说明它只使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是进行垃圾收集时必须暂停其他所有的工作线程直到它收集结束。到目前为止，Serial收集器依然是虚拟机运行在Client模式下的默认年轻代收集器(因为它的简单高效)</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573480545958.png\" alt=\"1573480545958\" class=\"article-img\"></p>\n<p>用户(桌面?听不清)应用场景中分配给虚拟机管理的内存一般不会很大，收集几十兆甚至一两百兆的年轻代停顿时间在几十毫秒到最大一百毫秒之间，只要不是频繁的发生，这些停顿是完全可以接受的</p>\n</li>\n<li><p>ParNew收集器(-XX:+UseParNewGC，复制算法)</p>\n<ul>\n<li>多线程收集，其他行为特点同Serial收集器一样</li>\n<li>单核执行效率不如Serial，在多核下执行才有优势</li>\n</ul>\n<p>在程序启动时通过设置-XX:+UseParNewGC使得年轻代使用该垃圾收集器回收。除了多线程收集，其他行为特点同Serial收集器一样。是Server模式下首选的年轻代收集器，在单个CPU环境中不会比Serial收集器有更好的效果。因为存在线程交互开销，随着可用CPU数量的增加，对于GC池系统资源的有效利用还是由好处的。默认开启的收集线程数与CPU数量相同。在CPU数量非常多的情况下可以使用一个叫做<strong>-XX:ParallelGCThreads</strong>的参数来限制垃圾收集的线程数。在Server模式下ParNew收集器是一个非常重要的收集器，因为除Serial外目前只有它可以和CMS收集器配合工作。它使用的也是复制算法。</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573481230113.png\" alt=\"1573481230113\" class=\"article-img\"></p>\n</li>\n</ul>\n<p>(参考博客：<a href=\"https://blog.csdn.net/wxy941011/article/details/80653738\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wxy941011/article/details/80653738</a>)</p>\n<ul>\n<li><p>Parallel Scavenge收集器(-XX:+UseParallelGC，复制算法)</p>\n<ul>\n<li>比起ParNew收集器关注用户线程停顿时间，更关注系统的吞吐量</li>\n<li>在多核执行下才有优势，Server模式下默认的年轻代收集器</li>\n</ul>\n<p>在程序启动时通过设置-XX:+UseParallelGC使得年轻代使用该垃圾收集器回收。Parallel Scavenge收集器与ParNew收集器类似，也采用复制算法和多线程进行垃圾回收，但是相较更关注系统的吞吐量(ParNew收集器关注用户线程停顿时间，停顿时间短适合于用户交互的程序，良好的响应速度能提升用户体验)。高吞吐量就可以高效利用CPU时间，尽可能快地完成任务。主要适合在后台运算而不需要太多交互任务的情况。Parallel Scavenge收集器是虚拟机运行在Server模式下默认的年轻代收集器</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573482027240.png\" alt=\"1573482027240\" class=\"article-img\"></p>\n</li>\n</ul>\n<p>  若对垃圾收集器运作原理不了解，以至于在优化过程中遇到困难时，可以使用Parallel Scavenge收集器配合自适应调节策略，以及在启动参数中添加-XX:+UseAdaptiveSizePolicy这个参数，会将内存管理的调优任务交给虚拟机完成</p>\n<h6 id=\"2-5-4-常见的老年代的收集器\">2.5.4 常见的老年代的收集器<a href=\"post/Java面试#2-5-4-常见的老年代的收集器\"></a></h6><p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573479725167.png\" alt=\"1573479725167\" class=\"article-img\"></p>\n<ul>\n<li><p>Serial Old收集器(-XX:+UseSerialOldGC，标记-整理算法)</p>\n<ul>\n<li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li>\n<li>简单高效，CLient模式下默认的老年代收集器</li>\n</ul>\n<p>在程序启动时通过设置-XX:+UseSerialOldGC使得老年代使用该垃圾收集器回收。是Serial收集器的老年版本，同样也是单线程的，使用标记-整理算法。除了采用的算法不是复制算法外，其他特点和年轻代中的Serial收集器一样</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573518120959.png\" alt=\"1573518120959\" class=\"article-img\"></p>\n</li>\n<li><p>Parallel Old收集器(-XX:+UseParallelOldGC，标记-整理算法)</p>\n<ul>\n<li>多线程，吞吐量优先</li>\n</ul>\n<p>在程序启动时通过设置-XX:UseParallelOldGC使得老年代使用该垃圾收集器回收。该收集器使用多线程的标记-整理算法去收集。在注重吞吐量及CPU资源敏感的场合都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器。</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573518099869.png\" alt=\"1573518099869\" class=\"article-img\"></p>\n</li>\n<li><p>CMS收集器(-XX:+UseConcMarkSweepGC，标记-清除算法)</p>\n<p>占据JVM老年代垃圾收集器的半壁江山，划时代的意义就是垃圾回收线程几乎能与用户线程做到同时工作。”几乎”是因为还是不能做到完全不需要stop-the-world，只是尽可能地缩短了停顿时间。若应用程序对停顿较为敏感并且在应用程序运行时可以提供更大的内存和更多的CPU(即更好的硬件)，那么使用CMS收集器会给你带来好处。若在JVM中有相对较多、存活较长的对象，会更适合使用CMS。</p>\n<p>垃圾回收过程：</p>\n<ul>\n<li><p>初始标记：stop-the-world</p>\n<p>在该阶段中需要虚拟机停顿正在执行的任务，该过程从垃圾回收的根对象开始，一直扫描到能够和根对象直接关联的对象并做标记。因此，虽然暂停了整个JVM，但很快就完成了。</p>\n</li>\n<li><p>并发标记：并发追溯标记，程序不会停顿</p>\n<p>该阶段紧随初始阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感觉到停顿。</p>\n</li>\n<li><p>并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象</p>\n<p>并发预清理阶段虚拟机查找执行并发标记阶段从年轻代晋升到老年代的对象，通过重新扫描减少下一阶段重新标记的工作(下一阶段会stop-the-world)</p>\n</li>\n<li><p>重新标记：暂停虚拟机，扫描CMS堆中的剩余对象</p>\n<p>这个阶段暂停虚拟机，垃圾收集(垃圾回收)线程扫描CMS堆中的剩余对象。扫描从根对象开始，向下追溯，并处理对象之间的关联(会相对较慢)</p>\n</li>\n<li><p>并发清理：清理垃圾对象，程序不会停顿</p>\n<p>清理垃圾对象，该阶段收集线程和应用程序线程并发执行</p>\n</li>\n<li><p>并发重置：重置CMS收集器的数据结构</p>\n<p>该阶段重置CMS收集器的数据结构，等待下一次垃圾回收</p>\n</li>\n</ul>\n<p>六个阶段中只有初始标记和重新标记是需要stop-the-world。</p>\n<p>并发标记的过程实际上就是和用户线程同时工作，即一边丢垃圾，一边打扫，这样就会带来一个问题：若垃圾的产生在标记后发生，那么这次垃圾就要等到下次再回收。等到垃圾标记过后，不会和用户线程产生冲突，而清理过程就能和用户线程同时处理</p>\n<p><strong>此垃圾收集器的缺点：采用标记-清除算法，即不会压缩存活的对象，会带来内存空间碎片化的问题。若出现需要分配一个连续且较大的内存空间，则只能触发一次GC</strong></p>\n</li>\n</ul>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573518360171.png\" alt=\"1573518360171\" class=\"article-img\"></p>\n<h6 id=\"2-5-5-G1收集器\">2.5.5 G1收集器<a href=\"post/Java面试#2-5-5-G1收集器\"></a></h6><p>G1收集器(-XX:+UseG1GC，复制+标记-整理算法)</p>\n<p>既用于年轻代，也用于老年代</p>\n<p>Garbage First收集器的特点：</p>\n<ul>\n<li><p>并发和并行</p>\n<p>使用多个CPU来缩短stop-the-world的时间，与用户线程并发执行</p>\n</li>\n<li><p>分代收集</p>\n<p>独立管理整个堆，但是采用不同的方式处理新创建的对象(年轻代，采用复制算法)和已经存活一段时间的对象(老年代，采用标记-整理算法)</p>\n</li>\n<li><p>空间整合</p>\n<p>基于标记-整理算法，解决了内存碎片的问题</p>\n</li>\n<li><p>可预测的停顿</p>\n<p>能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为m毫秒的时间片段内消耗在垃圾收集上的时间不超过n毫秒(通过设置)。</p>\n</li>\n</ul>\n<p>Garbage First收集器：</p>\n<ul>\n<li><p>将整个Java堆内存划分为多个大小相等的Region</p>\n</li>\n<li><p>年轻代和老年代不再物理隔离</p>\n<p>Garbage First收集器将整个Java堆内存划分为多个大小相等的独立区域Region。虽然仍保留新生代和老年代的概念，但年轻代和老年代不再物理隔离，都是一部分可以是不连续的Region的集合，也意味着分配空间时，不需要一个连续内存空间即不需要在JVM启动时决定哪些Region属于老年代哪些属于年轻代。因为随着时间推移，年轻代Region被回收以后就会变为可用状态，这时可以将其分配为老年代。G1收集器是并行stop-the-world收集器，和其他HotSpot GC一样，当一个年轻代GC发生时，整个年轻代都会被回收。G1收集器的老年代不同，在老年代不需要整个老年代进行回收，有一部分Region被调用，G1收集器的年轻代由Eden Region和Survivor Region组成，当一个JVM分配Eden Region失败后就会触发一个年轻代回收，意味着Eden区满了，GC开始释放空间。第一个年轻代收集器会移动所有的重组对象从Eden Region到Survivor Region。这就是Copy出Survivor的过程。</p>\n</li>\n</ul>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573518577568.png\" alt=\"1573518577568\" class=\"article-img\"></p>\n<h5 id=\"2-6-GC相关面试题\">2.6 GC相关面试题<a href=\"post/Java面试#2-6-GC相关面试题\"></a></h5><h6 id=\"2-6-1-Object的finalize-方法的作用是否与C-的析构函数作用相同\">2.6.1 Object的finalize()方法的作用是否与C++的析构函数作用相同<a href=\"post/Java面试#2-6-1-Object的finalize-方法的作用是否与C-的析构函数作用相同\"></a></h6><ul>\n<li><p>与C++的析构函数不同，析构函数调用确定，而它的是不确定的</p>\n<p>C++的析构函数调用时机是确定的，在对象离开作用域后，Java中的finalize()方法具有不确定性</p>\n</li>\n<li><p>将未被引用的对象置于F-Queue队列</p>\n<p>当垃圾回收器宣告一个对象死亡时，至少经过两次的标记过程。如果对象在进行可达性分析后发现没有和GC root相连的引用链就会被第一次标记，并且判断是否执行finalize()方法。如果对象覆盖finalize()方法且未被引用过，该对象就会被放置在F-Queue队列并在稍后由一个虚拟机自动建立的低优先级的finalize线程去执行触发finalize()方法</p>\n</li>\n<li><p>方法执行随时可能会被终止</p>\n<p>由于优先级较低，触发该方法后，不承诺等待其运行结束(即方法执行随时可能被终止)</p>\n</li>\n<li><p>给予对象最后一次重生的机会</p>\n<p>finalize()方法的作用是为对象创造最后一次逃脱死亡的机会。</p>\n</li>\n</ul>\n<p>如何使用finalize()方法：</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Finalization</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Finalization finalization;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Finalized\"</span>);</span><br><span class=\"line\">        finalization = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Finalization f = <span class=\"keyword\">new</span> Finalization();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"First print: \"</span> + f);</span><br><span class=\"line\">        f = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;<span class=\"comment\">//休息一段时间让上面的垃圾回收线程执行完成</span></span><br><span class=\"line\">            Thread.currentThread().sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Second print: \"</span> + f);</span><br><span class=\"line\">        System.out.println(f.finalization);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Out:</span></span><br><span class=\"line\">First print: GC.Finalization@<span class=\"number\">74</span>a14482</span><br><span class=\"line\">Finalized</span><br><span class=\"line\">Second print: <span class=\"keyword\">null</span></span><br><span class=\"line\">GC.Finalization@<span class=\"number\">74</span>a14482</span><br></pre></td></tr></table></div></figure>\n\n<p><strong>由于finalize()方法运行的不确定性较大，无法保证各对象的调用顺序，同时运行代价也高昂因此不建议使用</strong></p>\n<h6 id=\"2-6-2-Java中的强引用，软引用，弱引用，虚引用\">2.6.2 Java中的强引用，软引用，弱引用，虚引用<a href=\"post/Java面试#2-6-2-Java中的强引用，软引用，弱引用，虚引用\"></a></h6><p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573561582559.png\" alt=\"1573561582559\" class=\"article-img\"></p>\n<p>强引用&gt;软引用&gt;弱引用&gt;虚引用</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th align=\"center\">引用类型</th>\n<th>被垃圾回收时间</th>\n<th>用途</th>\n<th>生存时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">强引用</td>\n<td>从来不会</td>\n<td>创建对象的一般状态</td>\n<td>JVM停止运行时终止</td>\n</tr>\n<tr>\n<td align=\"center\">软引用</td>\n<td>在内存不足时</td>\n<td>对象缓存</td>\n<td>内存不足时终止</td>\n</tr>\n<tr>\n<td align=\"center\">弱引用</td>\n<td>在垃圾回收时</td>\n<td>对象缓存</td>\n<td>GC运行后终止</td>\n</tr>\n<tr>\n<td align=\"center\">虚引用</td>\n<td>Unknown</td>\n<td>标记、哨兵</td>\n<td>Unknown</td>\n</tr>\n</tbody></table></div></div>\n<ul>\n<li><p>强引用(Strong Reference)</p>\n<ul>\n<li><p>最普遍的引用：Object obj = new Object();</p>\n</li>\n<li><p>使用强引用，当内存空间不足时，JVM即使抛出OutOfMemoryError终止程序也不会回收具有强引用的对象</p>\n</li>\n<li><p>通过将对象设置为null来弱化引用(或等其超出对象生命周期范围)，使其被回收 </p>\n</li>\n</ul>\n</li>\n<li><p>软引用(Soft Reference)</p>\n<ul>\n<li><p>对象处在有用但非必须的状态</p>\n</li>\n<li><p>只有当内存空间不足时，GC会回收该引用的对象的内存</p>\n</li>\n<li><p>可以用来实现内存敏感的高速缓存(就无需担心OutOfMemoryError问题。因为软引用会在内存不足时回收同时由于一般情况下内存空间充足，相关对象会一直存在便于复用)</p>\n</li>\n<li><p>用法：</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);<span class=\"comment\">//强引用</span></span><br><span class=\"line\">SoftReference&lt;String&gt; softRef = <span class=\"keyword\">new</span> SoftReference&lt;String&gt;(str);<span class=\"comment\">//软引用</span></span><br></pre></td></tr></table></div></figure>\n\n\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>**还可配合引用队列使用**</code></pre><ul>\n<li><p>弱引用(Weak Reference)</p>\n<ul>\n<li><p>非必须的对象，比软引用更弱一些</p>\n</li>\n<li><p>GC时会被回收</p>\n</li>\n<li><p>被回收的概率不大，因为GC线程的优先级较低</p>\n</li>\n<li><p>适用于引用偶然被使用且不影响垃圾收集的对象</p>\n</li>\n<li><p>用法：</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);<span class=\"comment\">//强引用</span></span><br><span class=\"line\">WeakReference&lt;String&gt; weakRef = <span class=\"keyword\">new</span> Weak Reference&lt;String&gt;(str);<span class=\"comment\">//弱引用</span></span><br></pre></td></tr></table></div></figure>\n\n\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>**还可配合引用队列使用**</code></pre><ul>\n<li><p>虚引用(PhantomReference)</p>\n<ul>\n<li><p>不会决定对象的生命周期</p>\n</li>\n<li><p>任何时候都可能被垃圾收集器回收</p>\n</li>\n<li><p>跟踪对象被垃圾收集器回收的活动，起哨兵作用(GC在回收一个对象之前，如果发现一个对象具有虚引用，那么在回收之前会首先将该对象的虚引用加入到与之关联的引用队列当中，程序可通过判断引用队列是否已经加入虚引用来了解被引用的对象是否被GC回收)</p>\n</li>\n<li><p>必须和引用队列ReferenceQueue联合使用</p>\n</li>\n<li><p>用法：</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);<span class=\"comment\">//强引用</span></span><br><span class=\"line\">ReferenceQueue queue = <span class=\"keyword\">new</span> ReferenceQueue;<span class=\"comment\">//引用队列</span></span><br><span class=\"line\">PhantomReference ref = <span class=\"keyword\">new</span> PhantomReference(str,queue)</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<p>引用队列(ReferenceQueue)</p>\n<ul>\n<li>(名义上是一个队列)无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达</li>\n<li>存储关联的且被GC的软引用，弱引用以及虚引用</li>\n</ul>\n<h4 id=\"3-Java异常及常用工具类体系\">3. Java异常及常用工具类体系<a href=\"post/Java面试#3-Java异常及常用工具类体系\"></a></h4><h5 id=\"3-1-异常\">3.1 异常<a href=\"post/Java面试#3-1-异常\"></a></h5><p>异常处理机制主要回答了三个问题：</p>\n<ul>\n<li>What：异常类型回答了什么被抛出</li>\n<li>Where：异常堆栈跟踪回答了在哪里抛出</li>\n<li>Why：异常信息回答了为什么被抛出</li>\n</ul>\n<p>Java的异常体系：</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573562402221.png\" alt=\"1573562402221\" class=\"article-img\"></p>\n<p>Throwable是整个Java异常体系的顶层父类，Error和Exception分别是其的两个子类。</p>\n<p>从责任角度看：</p>\n<ul>\n<li>Error属于JVM需要负担的责任</li>\n<li>RuntimeException是程序应该负担的责任</li>\n<li>Checked Exception(可检查异常)是Java编译器应该负担的责任</li>\n</ul>\n<h6 id=\"3-1-1-Error和Exception的区别\">3.1.1 Error和Exception的区别<a href=\"post/Java面试#3-1-1-Error和Exception的区别\"></a></h6><p>即从概念角度解析Java的异常处理机制</p>\n<ul>\n<li>Error：程序无法处理的系统错误，编译器不做检查</li>\n<li>Exception：程序可以处理的异常，捕获后可能恢复</li>\n</ul>\n<p><strong>Error是程序无法处理的错误，Exception是可以处理的异常</strong></p>\n<h6 id=\"3-1-2-Exception的分类\">3.1.2 Exception的分类<a href=\"post/Java面试#3-1-2-Exception的分类\"></a></h6><p>RuntimeException：不可预知的，程序应当自行避免</p>\n<p>非RuntimeException：可预知的，从编译器校验的异常(不处理编译时不通过)</p>\n<h6 id=\"3-1-3-常见的Error以及Exception\">3.1.3 常见的Error以及Exception<a href=\"post/Java面试#3-1-3-常见的Error以及Exception\"></a></h6><ul>\n<li><p>Error</p>\n<ul>\n<li><p>NoClassDefFoundError：找不到class定义的异常</p>\n<p>原因：</p>\n<ul>\n<li><p>类依赖的class或jar不存在</p>\n</li>\n<li><p>类文件存在，但是存在不同域中</p>\n<p>对应的class在Java的classpath中不可用或者有多个不同的类加载器重复加载同一个class就可能出现上述问题</p>\n</li>\n<li><p>大小写问题，javac编译的时候无视大小写，可能编译出来的class文件与想要的不一样</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n</li>\n<li><p>StackOverflowError：深递归导致栈被耗尽而抛出的异常</p>\n</li>\n<li><p>OutOfMemoryError：内存溢出异常</p>\n</li>\n</ul>\n</li>\n<li><p>Exception</p>\n<ul>\n<li><p>RuntimeException</p>\n<ul>\n<li><p>NullPointerException：空指针引用异常</p>\n<p>应用试图在要求使用对象的地方使用null时抛出该异常。譬如说调用空的对象的实例方法、访问空的对象的属性、计算空对象长度等等。</p>\n</li>\n<li><p>ClassCastException：类型强制转换异常</p>\n<p>类型强制转换失败时抛出。A不是B的父类或子类，o是A的实例，当强制将o构造为类B的实例会抛出该异常</p>\n</li>\n<li><p>IllegalArgumentException：传递非法参数异常</p>\n<p>给方法传入不满足要求的参数，无论是不满足参数类型要求还是不满足个数，只要不满足都抛出该异常。</p>\n</li>\n<li><p>IndexOutOfBoundsException：下标越界异常</p>\n<p>数组索引值为负数或大于等于数组时抛出该异常。</p>\n</li>\n<li><p>NumberFormatException：数字格式异常</p>\n<p>试图将一个String转换为指定的数字类型，而该字符串确实不满足数字类型要求格式时抛出该异常。</p>\n</li>\n</ul>\n</li>\n<li><p>非RuntimeException</p>\n<ul>\n<li>ClassNotFoundException：找不到指定class的异常</li>\n<li>IOException: IO操作异常</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"3-1-4-Java的异常处理机制\">3.1.4 Java的异常处理机制<a href=\"post/Java面试#3-1-4-Java的异常处理机制\"></a></h6><ul>\n<li>抛出异常：创建异常对象，交由运行时系统处理(throws xxxException)</li>\n<li>捕获异常：寻找合适的异常处理器处理异常，否则终止运行(try-catch-finally)</li>\n</ul>\n<blockquote>\n<p><strong>Finally是先于return执行的逻辑</strong></p>\n</blockquote>\n<h5 id=\"3-2-Java集合框架\">3.2 Java集合框架<a href=\"post/Java面试#3-2-Java集合框架\"></a></h5><p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573865002541.png\" alt=\"1573865002541\" class=\"article-img\"></p>\n<ul>\n<li>List：有序集合，提供了便捷的访问、插入、删除等操作</li>\n<li>Set：不允许包含重复元素的集合，适用于保证元素唯一的场景</li>\n<li>Queue: Java提供的标准队列的实现</li>\n</ul>\n<h6 id=\"3-2-1-List\">3.2.1 List<a href=\"post/Java面试#3-2-1-List\"></a></h6><p>特点：</p>\n<ul>\n<li>有序：存储和取出的顺序一致</li>\n<li>可重复</li>\n<li>可通过索引操作元素</li>\n</ul>\n<p>分类：</p>\n<ul>\n<li>底层是数组：<ul>\n<li>ArrayList：线程不安全，效率高(ArrayList的动态扩容实际上是通过重新创建一个新的数组，赋予新的长度并覆盖掉原有数组实现的)</li>\n<li>Vector：线程安全，效率低</li>\n<li>Vector：线程安全，效率低</li>\n</ul>\n</li>\n<li>底层是链表：<ul>\n<li>LinkedList：线程不安全，效率高</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>数组的访问速度比链表快，但非尾部的增删涉及元素的移动，因此ArrayList和Vector查询快、增删慢</p>\n<p>而LinkedList查询慢、增删快</p>\n</blockquote>\n<h6 id=\"3-2-2-Set\">3.2.2 Set<a href=\"post/Java面试#3-2-2-Set\"></a></h6><p>特点：</p>\n<ul>\n<li>无序：存储和取出的顺序不一定一致</li>\n<li>元素唯一</li>\n</ul>\n<p>分类：</p>\n<ul>\n<li><p>底层是哈希表(HashMap)</p>\n<ul>\n<li>HashSet(保证元素唯一性)——HashMap时讲解<ul>\n<li>equals()</li>\n<li>hashCode()</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>底层是二叉树</p>\n<ul>\n<li><p>TreeSet(保证元素排序)</p>\n<p>TreeSet的核心在于排序。若不关心排序，使用HashSet将获得更高的性能；若关心排序则使用TreeSet。用到了两种排序方式：</p>\n<ul>\n<li>comparable接口：基于元素自身实现的Comparable接口的自然排序(需要重写equals、hashCode和compareTo方法)</li>\n<li>comparator接口：基于灵活的Comparator接口的客户化排序(实现Comparator接口的compare方法)</li>\n</ul>\n<p><strong>当客户化排序和自然排序共存时，以客户化排序优先</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"3-2-3-List和Set的区别\">3.2.3 List和Set的区别<a href=\"post/Java面试#3-2-3-List和Set的区别\"></a></h6><p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573865453418.png\" alt=\"1573865453418\" class=\"article-img\"></p>\n<h6 id=\"3-2-4-Map\">3.2.4 Map<a href=\"post/Java面试#3-2-4-Map\"></a></h6><p>用于保存具有映射关系的数据，都是&lt;key,values&gt;形式的。<strong>Map中的key是不可重复的，</strong>key是用于标识集合中的每项数据，values可以重复。由源码可知，Map中的key是通过Set组织,values是通过Collection组织的。</p>\n<p>Map的结构：</p>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573868703055.png\" alt=\"1573868703055\" class=\"article-img\"></p>\n<p><strong>经典面试题：HashMap、HashTable、ConcurrentHashMap的区别</strong></p>\n<ul>\n<li><p><strong>HashMap线程不安全，数据结构是数组+链表+红黑树</strong></p>\n</li>\n<li><p><strong>HashTable线程安全，锁住整个对象，数据结构是数组+链表</strong></p>\n</li>\n<li><p><strong>ConcurrentHashMap线程安全，CAS+同步锁，数据结构是数组+链表+红黑树</strong></p>\n</li>\n<li><p><strong>HashMap</strong></p>\n<p>put方法的逻辑：</p>\n<ol>\n<li>如果HashMap未被初始化，则先初始化</li>\n<li>对Key求Hash值，然后再计算table的下标</li>\n<li>如果没有碰撞(Table数组中对应的位置还没有相应的键值对)，则将键值对直接放入数组对应位置中</li>\n<li>如果碰撞了，以链表的方式链接到后面</li>\n<li>如果链表长度超过了阈值，就把链表转为红黑树</li>\n<li>如果链表长度低于6，就把红黑树转回链表</li>\n<li>如果节点已经存在(key值已存在)就替换key对应value的旧值</li>\n<li>如果桶满了(容量16*负载因子0.75)，就需要resize(扩容2倍后重排)</li>\n</ol>\n</li>\n<li></li>\n</ul>\n<p><img src=\"C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573869247876.png\" alt=\"1573869247876\" class=\"article-img\"></p>\n<h5 id=\"3-3-Java的IO机制\">3.3 Java的IO机制<a href=\"post/Java面试#3-3-Java的IO机制\"></a></h5><p><strong>面试题：BIO、NIO、AIO的区别</strong></p>\n<ul>\n<li><strong>BIO：Block-IO</strong></li>\n<li><strong>NonBlock-IO</strong></li>\n<li><strong>Asynchronous IO</strong></li>\n</ul>\n","next":{"title":"Mybatis(1)","link":"post/Mybatis(1)"},"plink":"http://YIzzzzz.github.io/post/Java面试/"}